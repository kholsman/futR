---
title: "futR"
author: "Kirstin Holsman"
output:
  html_document:
    df_print: paged
  html_notebook:
    toc: TRUE
    df_print: kable
    fig_caption: yes
    theme: flatly
  header-includes:
  - \usepackage{knputenc}
  - \usepackage{unicode-math}
  - \pagenumbering{gobble}
  word_document:
    fig_caption: yes
    fig_width: 4
    keep_md: yes
  pdf_document:
    toc: TRUE
    fig_caption: yes
    fig_height: 4
    fig_width: 5
    highlight: tango
    keep_tex: yes
    latex_engine: xelatex
---

<!--  rmarkdown:html_vignette -->
<!-- vignette: > -->
<!--   %\VignetteIndexEntry{futR documentation} -->
<!--   %\VignetteEngine{knitr::rmarkdown} -->
<!--   %\VignetteEncoding{UTF-8} -->

```{r setup1, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = F,eval=T}
 #knitr::opts_chunk$set(echo = TRUE)
 #source("R/make.R")       # loads packages, data, setup, etc.
 thisYr <- format(Sys.time(), "%Y")
 today  <- format(Sys.time(), "%b %d, %Y")
 knitr::opts_knit$set(root.dir = '../')
 
```


Repo maintained by:
Kirstin Holsman  
Alaska Fisheries Science Center  
NOAA Fisheries, Seattle WA  
**<kirstin.holsman@noaa.gov>**  
*Last updated: `r today`*  
   
---

<!-- # Overview {.tabset .tabset-dropdown} -->
# Overview{.tabset}

futR() is a generic Rpackage for fitting recruitment models to stock assessment estimates of spawning stock biomass and recruitment with or without climate covariates. The recruitment model is based on Template Model Builder (`TMB`) and formultations follow Maunder and Desriso (2011) using a generalized three parameter stock-recruitment model with environmental covariates (Deriso 1980; Schnute 1985). This includes Ricker (logistic), Beverton Holt, log-linear, and log-linear with biomass lagged by year 'y-1'. The model can be fit with and with out random effects on spawning stock biomass (SSB) and recruitment (R) (i.e., measurement error on SSB and rec) using the methods of  Porch and Lauretta (2016) and with the optional unbiased estimate of sigma (sensu Ludwid and Walters 1981, Porch and Lauretta 2016). Environmental covariates are optional but can be included as main effects or as interactions.

For more information see Holsman et al. 2020 Climate and trophic controls on groundfish recruitment in Alaska.


## Installing futR()

The package can be installed from github using the devtools package:

```{r devtools, echo=T,eval=F}
install.packages("devtools")
```

The projection package can then be installed to R directly:

```{r install, echo=T,eval=F}
devtools::install_github("kholsman/futR")
```

## Setting up the package:

The base function for fitting recruitment requires a data.frame of recruitment and spawning biomass:


```{r setup, echo=T,eval=T}


  # rm(list=ls())
  #___________________________________________
  # 1. Set things up
  #___________________________________________
  
  # load data, packages, setup, etc.
  source("R/make.R")
    
  #___________________________________________
  # 2. Compile futR	
  #___________________________________________
  
  compile('src/futR.cpp') # this will generate warnings - they can be ignored if "0" is returned

```

## Options

Now we can fit a set of models with and without covariates. There are various switches for fitting models:

### Recruitment formulations (rectype):  
1. Linear (gamma = 0)
2. Beverton Holt (gamma = -1)
3. Ricker (0 < gamma <1 ) ; gamma is estimated (tMethod):  
  *a. *link = cloglog  
  *b. *link = logit
4. Exponential (gamma=1, b<0)

### Observation error options (sigMethod):  
0. No observation error (tau = 0)
1. estimate sigma, random effects on SSB if tau >0, tau input
2. unbiased sigma estimate, tau input
3. as in 1 but with defined measurement error for rec (indep of random effects on Spawners/SSB)
4. as in 1 but with  defined measurement error for rec and Spawners/SSB)

### Link options (tMethod):  
1. cloglog link (g = 1-exp(-exp(gamma)))
2. logit link (g = exp(gamma)/(1+exp(gamma)))  
    
### Environmental effects (if set to "TRUE"" in estparm):  
* beta = effects on pre-lavarl/ effective number of spawners
* lamba = effects on post-spawning success (e.g., age 0+ survival)  
   

<!-- # Fit recruitment  {.tabset .tabset-pills} -->
# Base model  {.tabset}

Let's start by fitting based models (no climate covariates) with different options for observation error.

### Observation error options (sigMethod):  
0. No observation error (tau = 0)
1. estimate sigma, random effects on SSB if tau >0, tau input
2. unbiased sigma estimate, tau input
3. as in 1 but with defined measurement error for rec (indep of random effects on Spawners/SSB)
4. as in 1 but with  defined measurement error for rec and Spawners/SSB)

### Run this code first

```{r base, echo=T,eval=T,message=F,results='hide'}
  # load data, packages, setup, etc.
  source("R/make.R")

  # set up some demo data:
  rec        <-  rec_dat[[1]]
  env        <-  env_covars
  # z score the covariates:
  env[1,]    <-  as.numeric(scale(env_covars[1,]))
  env[2,]    <-  as.numeric(scale(env_covars[2,]))
  ration     <-  ration_tmb[,1]
  # 3.2 Set up data
  PAR$phases
  PAR$estparams
  # which parameters to estimate with futR?
  phases  = c(
    log_a        = 1, 
    log_b        = 1, 
    #logit_tau     = TRUE,
    beta         = 1,
    lambda       = 1,
    epsi_s       = 1,
    logsigma     = 1)
   estparams  = c(
    log_a        = TRUE, 
    log_b        = TRUE, 
    #logit_tau     = TRUE,
    beta         = FALSE,
    lambda       = TRUE,
    epsi_s       = FALSE,
    logsigma     = TRUE)
```

### Now explore different sigMethod settings starting with sigMethod = 0. Note comparitive plots at the bottom of each tab.

## sigMethod = 0

No observation error (tau = 0) on either SSB or rec estimates.

```{r fit0, echo=T,eval=T,message=F,results='hide'}
    
  # makeDat will make the input values, data, and phases for the model:
  datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  1, # set to 0
                    tMethod    =  1,
                    estparams  =  estparams,
                    typeIN     =  4,
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
          
    # run the basic model
  wd0 <- getwd()
  setwd("src")
  mm1_t0 <-  mm <-runmod(dlistIN=datlist,version='futR',recompile=T,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t0 <-  data.frame(model = "mm1_t0", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  mu   <- df1_t0%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df1_t0%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")
```

```{r plot0, fig.dim=c(10, 4),echo=F}
  # now plot the density of each parm:
  # now plot the density of each parm:
  p <-
    ggplot(data=df1_t0) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```


## sigMethod = 1

Observation error (tau = 0) random effects on SSB if tau >0. 

```{r fit1, echo=T,eval=T,message=F,results='hide'}
 
  # makeDat will make the input values, data, and phases for the model:
  datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  1, #estimate sigma, random effects on SSB if tau >0, tau input
                    tMethod    =  1,
                    estparams  =  estparams,
                    typeIN     =  4,
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)

  datlist$rs_dat$tau  <-  0.000001  
 
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t1 <-  mm <-  runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t1 <-  data.frame(model = "mm1_t1", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  df <- rbind(df1_t0, df1_t1)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")
 
   

```

```{r, fig.dim=c(10, 4),echo=F}
 # now plot the denisty of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```

## sigMethod = 2

Unbiased sigma estimate, tau input in order to get observeation error via SSB rand effects.

```{r fit2, echo=T,eval=T,message=F,results='hide'}
  # makeDat will make the input values, data, and phases for the model:
   datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  2, 
                    tMethod    =  1,
                    estparams  =  estparams,
                    typeIN     =  4,
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
  datlist$rs_dat$tau  <-  0.000001  
    
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t2 <-  mm <- runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t2 <-  data.frame(model = "mm1_t2", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  df <- rbind(df, df1_t2)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")

```

```{r plot2, fig.dim=c(10, 4),echo=F}
 # now plot the density of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```











## sigMethod = 3

Estimate sigma, observation error (tau = 0) random effects on SSB if tau >0,  but with defined measurement error for rec estimates (indep of random effects on Spawners/SSB)

```{r fit3, echo=T,eval=T,message=F,results='hide'}
  # makeDat will make the input values, data, and phases for the model:
   datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  3, 
                    tMethod    =  1,
                    estparams  =  estparams,
                    typeIN     =  4,
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
  datlist$rs_dat$tau  <-  0.000001  
    
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t3 <-  mm <- runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t3 <-  data.frame(model = "mm1_t3", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  df <- rbind(df, df1_t3)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")

```

```{r plot3, fig.dim=c(10, 4),echo=F}
 # now plot the density of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```

## sigMethod = 4

Estimate sigma, observation error (tau = 0) random effects on SSB if tau >0, but with  defined measurement error for rec and Spawners/SSB)


```{r fit4, echo=T,eval=T,message=F,results='hide'}
  # makeDat will make the input values, data, and phases for the model:
   datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  4, 
                    tMethod    =  1,
                    estparams  =  estparams,
                    typeIN     =  4,
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
  datlist$rs_dat$tau  <-  0.000001  
    
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t4 <-  mm <- runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t4 <-  data.frame(model = "mm1_t4", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  df <- rbind(df, df1_t4)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")

```

```{r plot4, fig.dim=c(10, 4),echo=F}
 # now plot the density of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```












