---
title: "futR()"
author: "Kirstin Holsman"
output:
  html_document:
    df_print: paged
  html_notebook:
    toc: TRUE
    df_print: kable
    fig_caption: yes
    theme: flatly
  header-includes:
  - \usepackage{knputenc}
  - \usepackage{unicode-math}
  - \pagenumbering{gobble}
  word_document:
    fig_caption: yes
    fig_width: 4
    keep_md: yes
  pdf_document:
    toc: TRUE
    fig_caption: yes
    fig_height: 4
    fig_width: 5
    highlight: tango
    keep_tex: yes
    latex_engine: xelatex
---

<!--  rmarkdown:html_vignette -->
<!-- vignette: > -->
<!--   %\VignetteIndexEntry{futR documentation} -->
<!--   %\VignetteEngine{knitr::rmarkdown} -->
<!--   %\VignetteEncoding{UTF-8} -->

```{r setup1, echo = F,eval=T}
 knitr::opts_chunk$set(echo = TRUE,warning = FALSE, message = FALSE) 
 #knitr::opts_chunk$set(echo = TRUE)
 #source("R/make.R")       # loads packages, data, setup, etc.
 thisYr <- format(Sys.time(), "%Y")
 today  <- format(Sys.time(), "%b %d, %Y")
 knitr::opts_knit$set(root.dir = '../')
 
```


Repo maintained by:
Kirstin Holsman  
Alaska Fisheries Science Center  
NOAA Fisheries, Seattle WA  
**<kirstin.holsman@noaa.gov>**  
*Last updated: `r today`*  
   
---

<!-- # Overview {.tabset .tabset-dropdown} -->
# Overview{.tabset}

futR() is a generic Rpackage for fitting recruitment models to stock assessment estimates of spawning stock biomass and recruitment with or without climate covariates. The recruitment model is based on Template Model Builder (`TMB`) and formulations follow Maunder and Deriso (2011) using a generalized three parameter stock-recruitment model with environmental covariates (Deriso 1980; Schnute 1985). This includes Ricker (logistic), Beverton Holt, log-linear, and log-linear with biomass lagged by year 'y-1'. The model can be fit with and with out random effects on spawning stock biomass (SSB) and recruitment (R) (i.e., measurement error on SSB and rec) using the methods of  Porch and Lauretta (2016) and with the optional unbiased estimate of sigma (sensu Ludwid and Walters 1981, Porch and Lauretta 2016). Environmental covariates are optional but can be included as main effects or as interactions.

For more information see Holsman et al. 2020 Climate and trophic controls on groundfish recruitment in Alaska.


## Installing futR()

The package can be installed from github using the devtools package:

```{r devtools, echo=T,eval=F}
install.packages("devtools")
```

The projection package can then be installed to R directly:

```{r install, echo=T,eval=F}
devtools::install_github("kholsman/futR")
```

## Options

We use the Deriso–Schnute three parameter model (Deriso 1980; Schnute 1985) to estimate recruitment (sensu Maunder and Deriso, 2011). This formulation is parameterized with an intercept term ($\alpha$), a slope term ($\beta$) and a third term $\gamma$, which allows for different formulations including linear ($\gamma=1$), Beverton–Holt($\gamma=-1$), and Ricker ($\gamma→0$):

$$\hat{R}_i  =  a\hat{S}_{i-1}{(1 - (b\gamma \hat{S}_{i-1})}^{1/\gamma})*e^{\sigma}$$
When $\gamma=1$, the model reduces to a linear model:
$$\hat{R}_i  = (a\hat{S}_{i-1} - a\hat{S}_{i-1}*(b \hat{S}_{i-1}))$$
Now we can fit a set of models with and without covariates. There are various switches for fitting models:

$$\hat{R}_i  =  a\hat{S}_{i-1}e^{\mathbf{\beta X}}{(1 - (b\gamma \hat{S}_{i-1}e^{\mathbf{\beta X}})}^{1/\gamma})e^{\mathbf{\lambda X}}*e^{\sigma}$$
where $\sigma$ is the estimated process error of recruitment ($\hat{R}_i$) in year $i$.Observation errors $\sigma_R$ and $\sigma_S$ can also be fit using a variety of sigMethod options (below). 

         
### Recruitment formulations (rectype):  
1. Linear (gamma = 0)
2. Beverton Holt (gamma = -1)
3. Ricker (0 < gamma <1 ) ; gamma is estimated (tMethod):  
  *a. *link = cloglog  
  *b. *link = logit
4. Exponential (gamma=1, b<0)

### Link options for Ricker models (tMethod):  
a. cloglog link (g = 1-exp(-exp(gamma)))
b. logit link (g = exp(gamma)/(1+exp(gamma)))  
  
### Observation error options (sigMethod):  
1. No observation error ($\tau=0$)
2. estimate sigma, random effects on SSB if $\tau>0$, $\tau$ input
3. as in 1 but with unbiased sigma estimate, $\tau$ input
4. as in 1 but with defined measurement error for rec (indep of random effects on Spawners/SSB)
5. as in 1 but with  defined measurement error for rec and Spawners/SSB)

### Environmental effects (if set to "TRUE"" in estparm):  
* beta  = vector of 0,1 effects on pre-larval/ effective number of spawners
* lamba = vector of 0,1 effects on post-spawning success (e.g., age 0+ survival)  
   
## Setting up the package

The base function for fitting recruitment requires a data.frame of recruitment and spawning biomass:

```{r setup, echo=T,eval=T,message=F,results='hide'}
  # rm(list=ls()); setwd("/Users/kholsman/Documents/GitHub/futR")
  #___________________________________________
  # 1. Set things up
  #___________________________________________

  # load data, packages, setup, etc.
  source("R/make.R")
    
  #___________________________________________
  # 2. Compile futR	
  #___________________________________________
  wd0 <- getwd()
  setwd("src")
    recompile('futR') 
  setwd(wd0)
  # this will generate warnings - they can be ignored if "0" is returned

```

<!-- # Fit recruitment  {.tabset .tabset-pills} -->
# Base model options (recType) {.tabset}

Let's start by fitting based models (no climate covariates) with different options for R/S relationships.

### Recruitment formulations (rectype):  
1. Linear (gamma = 0)
2. Beverton Holt (gamma = -1)
3. Ricker (0 < gamma <1 ) ; gamma is estimated (tMethod):  
  *a. *link = cloglog  
  *b. *link = logit
4. Exponential (gamma=1, b<0)

### Link options for Ricker models (tMethod):  
a. cloglog link (g = 1-exp(-exp(gamma)))
b. logit link (g = exp(gamma)/(1+exp(gamma)))  

### Run this code first

```{r baseR, echo=T,eval=T,message=F,results='hide'}
  
  # set up some demo data:
  rec        <-  rec_dat[[1]]
  env        <-  env_covars
  
  # z score the covariates:
  env[1,]    <-  as.numeric(scale(env_covars[1,]))
  env[2,]    <-  as.numeric(scale(env_covars[2,]))
  ration     <-  ration_tmb[,1]
  # 3.2 Set up data
  PAR$phases
  PAR$estparams
  # which parameters to estimate with futR?
  phases  = c(
    log_a        = 1, 
    log_b        = 1, 
    #logit_tau     = TRUE,
    beta         = 1,
    lambda       = 1,
    epsi_s       = 1,
    logsigma     = 1)
  
   estparams  = c(
    log_a        = TRUE, 
    log_b        = TRUE, 
    #logit_tau     = TRUE,
    beta         = FALSE,  # no env covariate
    lambda       = FALSE,  # no env covariate
    epsi_s       = FALSE,
    logsigma     = TRUE)
   
```

### Now let's explore different R/S relationship fits

## rectype = 1

Linear relationship (mean with variation with covars).
<!-- $\gamma = 0$ -->

<!-- $$R_i  =  aS_ie^{\mathbf{\beta X}}{(1 - (b\gamma S_ie^{\mathbf{\beta X}})}^{1/\gamma})e^{\mathbf{\lambda X}}*e^{\sigma}$$ -->
      
      $$ R_i = exp(a+{\mathbf{\beta X}} $$

```{r fitR1, echo=T,eval=T,message=F,results='hide'}
  
  # makeDat will make the input values, data, and phases for the model:
  datlist  <-  makeDat(
                    rectype    =  1, 
                    tauIN      =  0, 
                    sigMethod  =  1, # (default, no random effects)
                    #tMethod    =  1, #cloglog link (g = 1-exp(-exp(gamma)))
                    estparams  =  estparams,
                    estMode    =  1, 
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)

  # run the basic model
  wd0 <- getwd()
  setwd("src")
  mmR1_t1 <-  mm <-runmod(dlistIN   = datlist,
                          version   = 'futR',
                          recompile = TRUE,
                          simulate  = FALSE,
                          simnitr   = 1000)
  setwd(wd0)
  
  dfR1_t1 <-  data.frame(model = "mmR1_t1", 
                     estimate  = as.vector(mm$sim), 
                     parameter = names( mm$mle)[row(mm$sim)])

 mm$input$R_obs
 mm$input$S_obs
 mm$input$years
  r1_t1_fit <- rec_fit <- mm$pred%>%
    select(def,pred)%>%
    group_by(def) %>%
    filter(def%in%c("S_hat","S_obs","R_hat","R_obs"))%>%
    mutate(id = 1:n(), model = "recType=1") %>%  
    tidyr::spread(def, pred)%>%
    mutate(R_obsIN =  mm$input$R_obs, 
           S_obsIN =  mm$input$S_obs, 
           year =  mm$input$years) 
 
  #rm(mm)
  mu   <- dfR1_t1%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- dfR1_t1%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")
 

  
  
```

```{r plotR1, fig.dim=c(10, 4),echo=F}
  # now plot the density of each parm:
  # now plot the density of each parm:
  # p <-
  #   ggplot(data=df1_t0) +
  #   geom_density( aes(x=estimate, color=model))+
  #   facet_wrap(~parameter,scales="free")+ 
  #   geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
  #   theme_kir_EBM()

 col <- viridis::viridis_pal(1,begin=.3,end=.4)
  Rmax <- 1.05* max( max(rec_fit$R_obs), max(rec_fit$R_hat))
  Smax <- 1.05* max( max(rec_fit$S_obs), max(rec_fit$S_hat))
  prs <- ggplot(data =  rec_fit) +
      geom_point (aes(x=S_obs,y = R_obs),color=col(1),size =2)+ 
      coord_cartesian(ylim = c(0, Rmax),xlim = c(0, Smax))+
      geom_point (aes(x=S_obs,y = R_hat, color = model))+ 
      theme_kir_EBM()+scale_color_brewer(palette = "Spectral")
  prs
```

## rectype = 2

Linear relationship with spawners and covariates.
<!-- $\gamma = 0$ -->

<!-- $$R_i  =  aS_ie^{\mathbf{\beta X}}{(1 - (b\gamma S_ie^{\mathbf{\beta X}})}^{1/\gamma})e^{\mathbf{\lambda X}}*e^{\sigma}$$ -->
      
      $$ R_i = exp(a+{\mathbf{\beta X}+(b+{\mathbf{\lambda X})*log(S_hat_i) ); $$

```{r fitR2, echo=T,eval=T,message=F,results='hide'}
    
  # makeDat will make the input values, data, and phases for the model:
  datlist  <-  makeDat(
                    rectype    =  2, 
                    tauIN      =  0, 
                    sigMethod  =  1, # (default, no random effects)
                    #tMethod    =  1, #cloglog link (g = 1-exp(-exp(gamma)))
                    estparams  =  c(
                                    log_a        = TRUE, 
                                    log_b        = TRUE, 
                                    #logit_tau     = TRUE,
                                    beta         = FALSE,  # no env covariate
                                    lambda       = FALSE,  # no env covariate
                                    epsi_s       = FALSE,
                                    logsigma     = TRUE),
                    estMode    =  1, 
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)

  # run the basic model
  wd0 <- getwd()
  setwd("src")
  mmR2_t1 <-  mm <-runmod(dlistIN=datlist,
                          version='futR',
                          recompile=F,
                          simulate=FALSE,
                          simnitr = 1000)
  setwd(wd0)
  dfR2_t1 <-  data.frame(model = "mmR2_t1", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])

 mm$input$R_obs
 mm$input$S_obs
 mm$input$years
  r2_t1_fit <-mm$pred%>%
    select(def,pred)%>%
    group_by(def) %>%
    filter(def%in%c("S_hat","S_obs","R_hat","R_obs"))%>%
    mutate(id = 1:n(), model = "recType=2") %>%  
    tidyr::spread(def, pred)%>%
    mutate(R_obsIN =  mm$input$R_obs, 
           S_obsIN =  mm$input$S_obs, 
           year =  mm$input$years) 
  
  rec_fit<- rbind(rec_fit,r2_t1_fit)
 
  #rm(mm)
  mu   <- dfR2_t1%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- dfR2_t1%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")
  
  
  
```

```{r plotR2, fig.dim=c(10, 4),echo=F}
  # now plot the density of each parm:
  # now plot the density of each parm:
col <- viridis::viridis_pal(1,begin=.3,end=.4)
  Rmax <- 1.05* max( max(rec_fit$R_obs), max(rec_fit$R_hat))
  Smax <- 1.05* max( max(rec_fit$S_obs), max(rec_fit$S_hat))
  prs <- ggplot(data =  rec_fit) +
      geom_point (aes(x=S_obs,y = R_obs),color=col(1),size =2)+ 
      coord_cartesian(ylim = c(0, Rmax),xlim = c(0, Smax))+
      geom_point (aes(x=S_obs,y = R_hat, color = model))+ 
      theme_kir_EBM()+scale_color_brewer(palette = "Spectral")
  prs

  # p <-
  #   ggplot(data=df1_t2) +
  #   geom_density( aes(x=estimate, color=model))+
  #   facet_wrap(~parameter,scales="free")+ 
  #   geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
  #   theme_kir_EBM()


```

# Observation error options (sigMethod)  {.tabset}

Let's start by fitting based models (no climate covariates) with different options for observation error.

### Observation error options (sigMethod):  
0. No observation error (tau = 0)
1. estimate sigma, random effects on SSB if tau >0, tau input
2. unbiased sigma estimate, tau input
3. as in 1 but with defined measurement error for rec (indep of random effects on Spawners/SSB)
4. as in 1 but with  defined measurement error for rec and Spawners/SSB)

### Run this code first

```{r base, echo=T,eval=T,message=F,results='hide'}
  # load data, packages, setup, etc.
  source("R/make.R")

  # set up some demo data:
  rec        <-  rec_dat[[1]]
  env        <-  env_covars
  # z score the covariates:
  env[1,]    <-  as.numeric(scale(env_covars[1,]))
  env[2,]    <-  as.numeric(scale(env_covars[2,]))
  ration     <-  ration_tmb[,1]
  # 3.2 Set up data
  PAR$phases
  PAR$estparams
  # which parameters to estimate with futR?
  phases  = c(
    log_a        = 1, 
    log_b        = 1, 
    #logit_tau     = TRUE,
    beta         = 1,
    lambda       = 1,
    epsi_s       = 1,
    logsigma     = 1)
  
   estparams  = c(
    log_a        = TRUE, 
    log_b        = TRUE, 
    #logit_tau     = TRUE,
    beta         = FALSE,  # no env covariate
    lambda       = FALSE,  # no env covariate
    epsi_s       = FALSE,
    logsigma     = TRUE)
   
   
   tm_use      <- 2 # tMethod to use (logit link)
   rectype_use <- 3 # recType to use (Ricker)
   
```


### Now explore different sigMethod settings starting with sigMethod = 0. Note comparitive plots at the bottom of each tab.

## sigMethod = 1

The base model fits the lognormally distributed process error for recruitment ($\sigma$) using maximum likelihood (i.e., ordinary least squares). When sigMethod - 0, no observation error ($\tau = 0$) is estimated for either spawners (S) or recruitment (R) estimates.

```{r fit0, echo=T,eval=T,message=F,results='hide'}
    
  # makeDat will make the input values, data, and phases for the model:
  datlist  <-  makeDat(
                    tauIN      =  0,  # set tau to zero (no random effects)
                    sigMethod  =  0, 
                    #tMethod    =  tm_use, #cloglog link (g = 1-exp(-exp(gamma)))
                    estparams  =  estparams,
                    rectypeIN  =  rectype_use, #Ricker
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
  
  # run the basic model
  wd0 <- getwd()
  setwd("src")
  mm1_t0 <-  mm <-runmod(dlistIN=datlist,version='futR',recompile=T,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t0 <-  data.frame(model = "mm1_t0", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  mu   <- df1_t0%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df1_t0%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")
```

```{r plot0, fig.dim=c(10, 4),echo=F}
  # now plot the density of each parm:
  # now plot the density of each parm:
  p <-
    ggplot(data=df1_t0) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```


## sigMethod = 2


The base model fits the lognormally distributed process error for recruitment ($\sigma$) using maximum likelihood (i.e., ordinary least squares). Additionally, when sigMethod = 1 and $\tau$ is input ($0<\tau<1$), observation errors are estimated for recruitment and spawners. Observation errors are statistically independent, random normal variables with similar variance but because of lack of other information $\sigma_R$ is modeled as a function of process error via the $\tau$ scalar (see eq 4 in Porch, C. E., and M. V. Lauretta. 2016). Observation error for recruitment is modeled with log-normally distributed observation error as a function of $\sigma$ as:
$log\hat{R}_i\sim N(0,\sigma_R)$ where $\sigma_R=(1+\tau)*\sigma$
  
Similarly, spawner indices ($\hat{S}_{i-1}$) include log-normally distributed observation error as:
$log\hat{S}_{i-1} \sim N(0,\sigma_S)$ where $\sigma_S=\tau*\sigma$

```{r fit1, echo=T,eval=T,message=F,results='hide'}
 
  # makeDat will make the input values, data, and phases for the model:
  datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  1, 
                    #tMethod    =  tm_use, #cloglog link (g = 1-exp(-exp(gamma)))
                    estparams  =  estparams,
                    rectypeIN  =  rectype_use, #Ricker
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)

  datlist$rs_dat$tau  <-  0.000001  
 
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t1 <-  mm <-  runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t1 <-  data.frame(model = "mm1_t1", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  df <- rbind(df1_t0, df1_t1)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")
 
   

```

```{r, fig.dim=c(10, 4),echo=F}
 # now plot the denisty of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```

## sigMethod = 3

As in sigMethod = 2, except when sigMethod = 3 $\sigma$ is estimated using the unbiased sigma estimate (sensu Ludwig and Walters 1982):

$$\sigma_i =  \frac1{(n_y-k)}*({ \frac{{\epsilon_{Ri}}^2}{1+\tau} + \frac{{\epsilon_{S,i}}^2}{\tau} })$$
where 

  $$\epsilon_{Ri} = log(R_i) - log(\hat R_i) $$ 
  and 
   $$\epsilon_{Si} = log(S_i) - log(\hat S_i) $$ 

```{r fit2, echo=T,eval=T,message=F,results='hide'}
  # makeDat will make the input values, data, and phases for the model:
   datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  2, 
                    #tMethod    =  tm_use, #cloglog link (g = 1-exp(-exp(gamma)))
                    estparams  =  estparams,
                    rectypeIN  =  rectype_use, #Ricker
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
  datlist$rs_dat$tau  <-  0.000001  
    
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t2 <-  mm <- runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t2 <-  data.frame(model = "mm1_t2", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  df <- rbind(df, df1_t2)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")

```

```{r plot2, fig.dim=c(10, 4),echo=F}
 # now plot the density of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```

## sigMethod = 4

As in sigMethod = 2 with observation error (random effects) on S if $\tau >0$,  but with defined measurement error for recruitment estimates (independent of random effects on spawners) such that:

  $log\hat{R}_i\sim N(0,\sigma_R)$  where $\sigma_{R,i}=\sigma_i+stdev(R_i)$.
 and 
 $log\hat{S}_{i-1} \sim N(0,\sigma_S$ where $\sigma_S=\tau*\sigma$.

         
         
```{r fit3, echo=T,eval=T,message=F,results='hide'}
  # makeDat will make the input values, data, and phases for the model:
   datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  3, 
                    #tMethod    =  tm_use, #cloglog link (g = 1-exp(-exp(gamma)))
                    estparams  =  estparams,
                    rectypeIN  =  rectype_use, #Ricker
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
  datlist$rs_dat$tau  <-  0.000001  
    
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t3 <-  mm <- runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t3 <-  data.frame(model = "mm1_t3", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  df <- rbind(df, df1_t3)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")

```

```{r plot3, fig.dim=c(10, 4),echo=F}
 # now plot the density of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```

## sigMethod = 4

As in sigMethod = 2 with observation error (random effects) on S and R if $\tau >0$,  but with defined measurement error for recruitment and spawner estimates (independent of random effects on spawners) such that:

  $log\hat{R}_i\sim N(0,\sigma_R)$  where $\sigma_{R,i}=((1+\tau)*\sigma_i)+stdev(R_i)$.
 and 
 $log\hat{S}_{i-1} \sim N(0,\sigma_S$ where $\sigma_S=(\tau*\sigma)+stdev(S_i)$.

Note that $\tau = 0$ defaults to the input variance for S and R as offsets for each.


```{r fit4, echo=T,eval=T,message=F,results='hide'}
  # makeDat will make the input values, data, and phases for the model:
   datlist  <-  makeDat(
                    tauIN      =  1,
                    sigMethod  =  4, 
                    #tMethod    =  tm_use, #cloglog link (g = 1-exp(-exp(gamma)))
                    estparams  =  estparams,
                    rectypeIN  =  rectype_use, #Ricker
                    rec_years  =  rec$years,
                    Rec        =  rec$Robs,
                    SSB        =  rec$SSB,
                    sdSSB      =  rec$sdSSB,
                    sdRec      =  rec$sdRobs,
                    covars     =  NULL,
                    covars_sd  =  NULL)
  datlist$rs_dat$tau  <-  0.000001  
    
  # re-run the model with tau 
  wd0 <- getwd()
  setwd("src")
  mm1_t4 <-  mm <- runmod(dlistIN=datlist,version='futR',recompile=F,simulate=TRUE,simnitr = 1000)
  setwd(wd0)
  df1_t4 <-  data.frame(model = "mm1_t4", 
                     estimate=as.vector(mm$sim), 
                     parameter=names( mm$mle)[row(mm$sim)])
  rm(mm)
  
  df <- rbind(df, df1_t4)
  mu   <- df%>%group_by(model,parameter)%>%summarise(grp.mean=mean(estimate))
  peak <- df%>%group_by(model,parameter)%>%
    count(parameter,round(estimate,1))%>%
    slice(which.max(n))
  names(peak)<- c("model","parameter","freq","n")

```

```{r plot4, fig.dim=c(10, 4),echo=F}
 # now plot the density of each parm:
  p <-
    ggplot(data=df) +
    geom_density( aes(x=estimate, color=model))+
    facet_wrap(~parameter,scales="free")+ 
    geom_vline(data=peak,aes(xintercept=freq, color = model), linetype="dashed", size=1)+
    theme_kir_EBM()
p
```












