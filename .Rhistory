sdRec = NULL,
typeIN,
tauIN =  1,
gammaIN = NULL,
estparams  = c(
log_a        = TRUE,
log_b        = TRUE,
#logit_tau    = FALSE,
gamma        = FALSE,
beta         = FALSE,
lambda       = TRUE,
epsi_s       = FALSE,
logsigma     = TRUE),
covars    = NULL,
covars_sd = NULL,
startVal  = NULL,
phases    = NULL,
fityrs    = NULL ,
REcompile = TRUE,
Eat_cov   = NULL,
tMethod   = 1,
sigMethod = NULL) {
inputs<-list(
dataIN     = data.frame(rec_years,SSB,Rec,sdSSB,sdRec),
typeIN     = typeIN,
tauIN      = tauIN,
estparams  = estparams,
covars     = covars,
covars_sd  = covars_sd,
startVal   = startVal,
phases     = phases,
fityrs     = fityrs ,
#rationIN   = rationIN,
REcompile  = REcompile,
#Eat_cov    = Eat_cov,
tMethod    = tMethod,
sigMethod  = sigMethod)
allyrs       <-  rec_years
# if(is.null(rationIN))
#   rationIN<-rep(0,length(allyrs))
ix<-1:length(allyrs)
if(!is.null(fityrs))
ix           <-  which(allyrs%in%fityrs)
if(is.null(typeIN)) typeIN <-3
rs_dat<-list()
rs_dat$rectype         <-
rs_dat$years           <-
rs_dat$S_obs           <-
rs_dat$R_obs           <-
rs_dat$sdS             <-
rs_dat$sdR             <-
rs_dat$rs_cov          <-
rs_dat$sdrs_cov        <-
rs_dat$nyrs            <-
rs_dat$cov_type        <-
rs_dat$ncov            <-
rs_dat$sigMethod       <-
rs_dat$tMethod         <-
rs_dat$tau             <-  NA
rs_dat$rectype         <-  typeIN
rs_dat$tMethod         <-  tMethod
rs_dat$years           <-  allyrs[ix]
rs_dat$S_obs           <-  SSB[ix]  #Rec[y]~  S_obs[y-1]
rs_dat$R_obs           <-  Rec[ix]  #Rec[y]~  S_obs[y-1]
#rs_dat$Ration_scaled   <-  rationIN[ix]
if(!is.null(covars))
rs_dat$rs_cov        <-  covars[,ix]
rs_dat$sdrs_cov        <-  rs_dat$rs_cov*0
if(!is.null(covars_sd))
rs_dat$sdrs_cov      <-  covars_sd[,ix]
rs_dat$tau             <-  tauIN
if(is.null(sdSSB))  { rs_dat$sdS <- rep(0,length(ix))}else{rs_dat$sdS <- sdSSB}
if(is.null(sdRec))  { rs_dat$sdR <- rep(0,length(ix))}else{rs_dat$sdR <- sdRec}
if(is.null(covars)){
rs_dat$rs_cov    <-   t(data.frame(NOcov=rep(0,length(ix))))
rs_dat$ncov      <-   NULL
estparams["beta"] <- FALSE
estparams["lambda"] <- FALSE
}else{
rs_dat$ncov      <-   dim(covars)[1]
if(rs_dat$ncov==1){
rs_dat$rs_cov    <-    t(as.matrix(rs_dat$rs_cov))
rs_dat$sdrs_cov  <-    t(as.matrix(rs_dat$sdrs_cov))
}
}
gamma <- -2
if(!is.null(gammaIN)) gamma <- gammaIN
rs_dat$cov_type  <-    rep(0,length(ix))
rs_dat$tMethod           <-   tMethod
rs_dat$cov_type          <-    rep(0,length(ix))
rs_dat$tMethod           <-    tMethod
if(sigMethod!=2&estparams['logsigma']){
rs_dat$sigMethod           <-   sigMethod
estparams['logsigma']      <-   TRUE
}else{
rs_dat$sigMethod           <-   sigMethod
estparams['logsigma']      <-   FALSE
}
# if(!is.null(Eat_cov))
#   rs_dat$cov_type[Eat_cov]   <-   1
rs_dat$nyrs            <-  dim(rs_dat$rs_cov)[2]
rs_dat$ncov            <-  dim(rs_dat$rs_cov)[1]
#___________________________________________
# 4.1 set initial conditions:
ln_mn_rec     <-  mean(log(Rec[ix]))
ln_mn_SSB     <-  mean(log(SSB[ix]))
if(typeIN==1){
#Linear
tmp_a       =  .8*ln_mn_rec
tmp_b       =  1.0/log(ln_mn_SSB)
tmpg        =  0
aphase      =  1
bphase      = -4
gphase      = -4
sigma_phase =  2
}
if(typeIN==2){
#BH
tmp_a       =   1.2
tmp_b       =  -ln_mn_rec
tmpg        =   0
bphase      =   1
aphase      =   1
gphase      =  -4
sigma_phase =   2
}
if(typeIN==3){
#Ricker
tmp_a       =   1.2
tmp_b       =  -ln_mn_rec
tmpg        =   gamma
# if(tMethod ==1)
#   tmpg  = 1-exp(-exp(gamma))
# if(tMethod ==2)
#   tmpg  = exp(gamma)/(1+exp(gamma))
bphase      =   1
aphase      =   1
gphase      =   2
sigma_phase =   2
}
if(typeIN==4){
tmp_a       =  .8*ln_mn_rec
tmp_b       =   -ln_mn_rec
tmpg        =   1
bphase      =   1
aphase      =   1
gphase      =  -4
sigma_phase =   2
}
if(is.null(phases)){
phases      <-   c(
log_a        = aphase,
log_b        = bphase ,
gamma       = gphase,
#logit_tau    = sigma_phase,
beta         = aphase+1,
lambda       = aphase+1,
epsi_s       = aphase+2,
logsigma     = sigma_phase)
}
parameters      <-   list(
log_a        = tmp_a,
log_b        = tmp_b ,
#logit_tau    = -10,
gamma        = tmpg ,
beta         = rep(0,rs_dat$ncov),
lambda       = rep(0,rs_dat$ncov),
#epsi_s       = rep(0,rs_dat$nyrs),
epsi_s       = 0,
logsigma     = log(.9))
if(!is.null(startVal)){
if(!any(names(startVal)%in%names(parameters))) stop("startVal names do not match parameters")
tmpc<-which(names(startVal)%in%names(parameters))
for(ii in 1:length(tmpc))
parameters[[ names(startVal)[ii] ]]<-startVal[[ii]]
}
maplist<-makeMap(param=parameters,estpar=estparams)
return(list(parameters = parameters, rs_dat = rs_dat, maplist= maplist,estparams = estparams, phases=phases,inputs=inputs))
}
datlist  <-  makeDat(
tauIN      =  1,
sigMethod  =  1,
tMethod    =  1,
estparams  =  estparams2,
typeIN     =  4,
rec_years  =  rec$years,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
covars     =  NULL,
covars_sd  =  NULL)
mm1                 <-  runmod(dlistIN=datlist,version="src/futR",recompile=T,simulate=TRUE)
datlist$estparams
datlist$maplist
datlist$parameters
estparams
estpar=estparams
param=datlist$parameters
1:length(unlist(param))
param
mapseq  <- 1:length(unlist(param))
ixx     <- 0
maplist <- param
maplist
names(estpar)
inm <-1
estpar[[inm]]
1:length(param[[inm]])+rev(ixx)[1]
maplist
param
names(estpar)
#-------------------------------------
# makeMap
#-------------------------------------
#' makeMap will create a map list for reading into the futR function
#'
#' This function prepares the estimated data for futR
#' For more information contact author Kirstin Holsman (kirstin.holsman@noaa.gov)
#' @weblink
#' @param parameters  parameters for the tmb function
#' @param estpar      a vector of integers indicating phase. NA results in no estimation.
#' @export            maplist a list with map values
#' @email             For more information contact author Kirstin Holsman (kirstin.holsman@noaa.gov)
#' @examples
#'
#' mod<-estRec(dataINUSE  =  dataIN_admb)
#'
makeMap<-function(param=parameters,estpar=estparams){
mapseq  <- 1:length(unlist(param))
ixx     <- 0
maplist <- param
for(inm in names(param)){
if(estpar[[inm]]){
ixx             <-  1:length(param[[inm]])+rev(ixx)[1]
maplist[[inm]]  <- factor(ixx)
}else{
maplist[[inm]]  <- factor(rep(NA,length(maplist[[inm]])))
}
}
return(maplist)
}
names(param)
inm <-"gamma"
(estpar[[inm]])
(inm %in% names(estpar))
#-------------------------------------
# makeMap
#-------------------------------------
#' makeMap will create a map list for reading into the futR function
#'
#' This function prepares the estimated data for futR
#' For more information contact author Kirstin Holsman (kirstin.holsman@noaa.gov)
#' @weblink
#' @param parameters  parameters for the tmb function
#' @param estpar      a vector of integers indicating phase. NA results in no estimation.
#' @export            maplist a list with map values
#' @email             For more information contact author Kirstin Holsman (kirstin.holsman@noaa.gov)
#' @examples
#'
#' mod<-estRec(dataINUSE  =  dataIN_admb)
#'
makeMap<-function(param=parameters,estpar=estparams){
mapseq  <- 1:length(unlist(param))
ixx     <- 0
maplist <- estpar
for(inm in names(param)){
if(inm %in% names(estpar)){
if(estpar[[inm]]){
ixx             <-  1:length(param[[inm]])+rev(ixx)[1]
maplist[[inm]]  <- factor(ixx)
}else{
maplist[[inm]]  <- factor(rep(NA,length(maplist[[inm]])))
}
}else{
maplist[[inm]]    <- factor(rep(NA,length(maplist[[inm]])))
}
}
return(maplist)
}
datlist  <-  makeDat(
tauIN      =  1,
sigMethod  =  1,
tMethod    =  1,
estparams  =  estparams2,
typeIN     =  4,
rec_years  =  rec$years,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
covars     =  NULL,
covars_sd  =  NULL)
mapseq  <- 1:length(unlist(param))
ixx     <- 0
maplist <- estpar
maplist
estpar
mapseq  <- 1:length(unlist(param))
ixx     <- 0
maplist <- param
datlist$parameters
mapseq  <- 1:length(unlist(param))
ixx     <- 0
maplist <- param
for(inm in names(param)){
if(inm %in% names(estpar)){
if(estpar[[inm]]){
ixx             <-  1:length(param[[inm]])+rev(ixx)[1]
maplist[[inm]]  <- factor(ixx)
}else{
maplist[[inm]]  <- factor(rep(NA,length(maplist[[inm]])))
}
}else{
maplist[[inm]]    <- factor(rep(NA,length(maplist[[inm]])))
}
}
maplist
#-------------------------------------
# makeMap
#-------------------------------------
#' makeMap will create a map list for reading into the futR function
#'
#' This function prepares the estimated data for futR
#' For more information contact author Kirstin Holsman (kirstin.holsman@noaa.gov)
#' @weblink
#' @param parameters  parameters for the tmb function
#' @param estpar      a vector of integers indicating phase. NA results in no estimation.
#' @export            maplist a list with map values
#' @email             For more information contact author Kirstin Holsman (kirstin.holsman@noaa.gov)
#' @examples
#'
#' mod<-estRec(dataINUSE  =  dataIN_admb)
#'
makeMap<-function(param=parameters,estpar=estparams){
mapseq  <- 1:length(unlist(param))
ixx     <- 0
maplist <- param
for(inm in names(param)){
if(inm %in% names(estpar)){
if(estpar[[inm]]){
ixx             <-  1:length(param[[inm]])+rev(ixx)[1]
maplist[[inm]]  <- factor(ixx)
}else{
maplist[[inm]]  <- factor(rep(NA,length(maplist[[inm]])))
}
}else{
maplist[[inm]]    <- factor(rep(NA,length(maplist[[inm]])))
}
}
return(maplist)
}
datlist  <-  makeDat(
tauIN      =  1,
sigMethod  =  1,
tMethod    =  1,
estparams  =  estparams2,
typeIN     =  4,
rec_years  =  rec$years,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
covars     =  NULL,
covars_sd  =  NULL)
# run the model
mm1                 <-  runmod(dlistIN=datlist,version="src/futR",recompile=T,simulate=TRUE)
datlist  <-  makeDat(
tauIN      =  1,
sigMethod  =  1,
tMethod    =  1,
estparams  =  estparams,
typeIN     =  4,
rec_years  =  rec$years,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
covars     =  NULL,
covars_sd  =  NULL)
# run the model
mm1                 <-  runmod(dlistIN=datlist,version="src/futR",recompile=T,simulate=TRUE)
df1                 <-  data.frame(estimate=as.vector(mm1$sim), parameter=names( mm1$mle)[row(mm1$sim)])
densityplot( ~ estimate | parameter, data=df1, layout=c(5,1),ylim=c(0,10))
#now change tau
datlist$rs_dat$tau  <-  0.000001
# re-run the model with tau
mm1_t0              <-  runmod(dlistIN=datlist,version="futR",recompile=F,simulate=TRUE)
df1_t0              <-  data.frame(estimate=as.vector(mm1_t0$sim), parameter=names( mm1_t0$mle)[row(mm1_t0$sim)])
densityplot( ~ estimate | parameter, data=df1_t0, layout=c(5,1),ylim=c(0,10))
datlist  <-  makeDat(
tauIN      =  1,
sigMethod  =  2,
estparams  =  estparams,
typeIN     =  4,
rec_years  =  rec$years,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
covars   =  env)
R_hat<-function(N,gamma=-1,b=1,loga=1,beta=.2,lambda=.2,x){
sapply(N,function(NIn=N,gammaIN=gamma,bIn=b,logaIn=loga,betaIn=beta,lambdaIn=lambda){
gN <- NIn*exp(sum(lambdaIn*x))
hx <- exp(sum(betaIn*x))
return( exp(loga)*gN* ((1-bIn*gammaIN*gN)^(1/gammaIN))*hx)
}
)}
bseq<-seq(0,1,.01)
plot(bseq,R_hat(N=100,gamma=-1,b=bseq,a=1,beta=.2,lambda=.2,x=bseq),type="l")
gseq<-seq(-1,1,.01)
Nseq <- seq(0,200,1)
xseq <-Nseq*0
BETA <- 0
LAMBDA <-0
# ricker
plot(Nseq,R_hat(N=Nseq,gamma=.3,b=.01,loga=1,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
# Bev holt
lines(Nseq,R_hat(N=Nseq,gamma=-1,b=.1,loga=2,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
#linear
lines(Nseq,R_hat(N=Nseq,gamma=0,b=.1,loga=-1.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
#exponential:
lines(Nseq,R_hat(N=Nseq,gamma=1,b=-0.002,loga=-1.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l",col="red")
lines(Nseq,R_hat(N=Nseq,gamma=0,b=0,loga=-2.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l",col="blue")
Nseq
R_hat
R_hat<-function(N,gamma=-1,b=1,loga=1,beta=.2,lambda=.2,x){
sapply(N,function(NIn=N,gammaIN=gamma,bIn=b,logaIn=loga,betaIn=beta,lambdaIn=lambda){
gN <- NIn*exp(sum(lambdaIn*x))
hx <- exp(sum(betaIn*x))
return( exp(loga)*gN* ((1-bIn*gammaIN*gN)^(1/gammaIN))*hx)
}
)}
bseq<-seq(0,1,.01)
plot(bseq,R_hat(N=100,gamma=-1,b=bseq,a=1,beta=.2,lambda=.2,x=bseq),type="l")
gseq<-seq(-1,1,.01)
Nseq <- seq(0,200,1)
xseq <-Nseq*0
BETA <- 0
LAMBDA <-0
# ricker
plot(Nseq,R_hat(N=Nseq,gamma=.3,b=.01,loga=1,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
lines(Nseq,R_hat(N=Nseq,gamma=-1,b=.1,loga=2,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
lines(Nseq,R_hat(N=Nseq,gamma=0,b=.1,loga=-1.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
lines(Nseq,R_hat(N=Nseq,gamma=1,b=-0.002,loga=-1.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l",col="red")
lines(Nseq,R_hat(N=Nseq,gamma=0,b=0,loga=-2.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l",col="blue")
x_seq2<-datlist[[6]][[1]]$S_obs*0
plot(datlist[[6]][[1]]$S_obs,R_hat(N=datlist[[6]][[1]]$S_obs,gamma=a,b=-12.3076257,loga=1.2,beta=0,lambda=0,x=x_seq2),type="p")
g<- 0.126577
a<-3.320117
b<-4.517166e-06
S_obs<-rec$S_obs
Acovars<-Bcovars<-0
plot(S_obs,R_hat(N=S_obs,gamma=g,b=b,loga=log(a)/10,beta=0,lambda=0,x=x_seq2),type="p")
plot(S_obs,R_hat)
LAMBDA <-0
nobs  <- length(Nseq)
err   <- rnorm(nobs,0,.2)
AC    <- 1.2
xseq <-exp(err+c(0,err[-nobs])*AC)
xseq <- rep(2,nobs)
xseq2 <- rep(-2,nobs)
plot(xseq,type="l")
plot(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=.002,lambda=LAMBDA,x=xseq),type="l",lty=2,col="red")
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0,lambda=LAMBDA,x=xseq),type="l")
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=.002,lambda=LAMBDA,x=xseq2),type="l",lty=2)
plot(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0,lambda=0.002,x=xseq2),type="l",lty=2)
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0,lambda=0,x=xseq),type="l")
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0,lambda=.002,x=xseq),type="l",lty=2,,col="red")
plot(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0.0,lambda=0,x=xseq2),type="l")
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0.002,lambda=.002,x=xseq),type="l",lty=2)
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0.002,lambda=.002,x=xseq2),type="l",lty=2,,col="red")
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0.002,lambda=-.002,x=xseq2),type="l",lty=2,,col="red")
lines(Nseq,R_hat(N=Nseq,gamma=0.12,b=.1,a=30,beta=0.002,lambda=-.002,x=xseq),type="l",lty=2,,col="red")
x<-seq(0,1,.01)
x1<- log(-log(1-x))
plot(x,x1,type="l",ylim=c(-4,4))
x2<-  log((x/(1-x)))
lines(x,x2,lty=2)
# GET_ESTM2
GET_ESTM2 <- function(mode, s = 1){
plotdat     <-  smry_RS[[s]]
Rectxt      <-  Rec_2$TopR2.txt[[s]]
Rectxt_aic  <-  Rec_2$TopAIC.txt[[s]]
rec_path    <-  rec_fldr
estnm       <-  file.path(mod_fldr,"results/ceattle_est.std")
rsdat       <-  rs_data
covv        <-  covuse.all
return(list(covv = covv,  Rectxt = Rectxt, Rectxt_aic = Rectxt_aic,rsdat=rsdat,estnm=estnm,rec_path=rec_path,plotdat=plotdat))
}
main
est       <-  read.csv("data/ignore/raw/ceattle_est_aclim_00_JunV3_2019_2.std",sep = " ")
est
head(est)
est       <-  read.csv("data/ignore/raw/ceattle_est_aclim_00_JunV3_2019_2.std",sep = "")
est
head(estt)
head(est)
est%>%filter(name="ln_mn_rec")
est%>%filter(name=="ln_mn_rec")
ln_mn_rec <-  est%>%filter(name=="ln_mn_rec")
names(est$name)
unqiue(est$name)
unique(est$name)
est       <-  read.csv("data/ignore/raw/ceattle_est_aclim_00_JunV3_2019_2.std",sep = "")
ln_mn_rec <-  est%>%filter(name=="ln_mn_rec")
rec_dev   <-  est%>%filter(name=="rec_dev")
rec_dev
dim(rec_dev)
dim(rec_dev)/dim(ln_mn_rec)
nyrs      <-  (dim(rec_dev)/dim(ln_mn_rec))[1]
nyrs
