rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
beta_0     =  datlist$rs_dat$beta_0,
lambda_0   =  datlist$rs_dat$lambda_0,
covars     =  datlist$rs_dat$rs_cov,
covars_sd  =  datlist$rs_dat$sdrs_cov)
# set the rectype to 4
datlist3$rs_dat$rectype <- 4
# run the basic model
Rec4_covar <-  mm <-runmod(dlistIN   = datlist,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# summarize results
dfR4_c    <-  data.frame(model = "Rec 4 cov2",
estimate  = as.vector(mm$sim),
parameter = names( mm$mle)[row(mm$sim)])
df      <- rbind(dfR4,dfR4_c)
r4_fitc  <- getFit(mm, nm = "recType = 4 cov2")
rec_fit <- rbind(r4_fit,r4_fitc)
rm(mm)
#plot_par_pdf(df)
plot_rs(rec_fit)
library(wesanderson)
plt     <- c("Zissou1","Darjeeling1","Darjeeling2","FantasticFox1")
dawn    <- colorRampPalette(c(colors()[c(477,491,72,474,47,653)],"orange","red"))
Ornjazz <- RColorBrewer::brewer.pal(5, "Oranges")
orng    <- colorRampPalette(Ornjazz[1:5])
blues   <- RColorBrewer::brewer.pal(5, "Blues")
BG      <- RColorBrewer::brewer.pal(9, "GnBu")  #5
wes     <- colorRampPalette(c(wes_palette(n=5, name=plt[1])[1:5]))
col2    <- colorRampPalette(c(wes(7)[c(3,1)],orng(3)[3]))
col3    <- colorRampPalette(c(wes(7)[4:7]))
coll_use <-  c(colors()[320],col2(6)[c(2,3,4)],col3(6)[c(3,4,6)])
# load Kir's theme:
source("~/Documents/D_AFSC_Files/AFSC_code/R_scripts/Misc_scripts/THEMES_GGPLOT.r")
source("D:/GitHub_cloud/futR/R/sub_fun/THEMES_GGPLOT.R")
# Plot comparisons of recruitment from ADMB and TMB
plotCompareMod<-function(H=7,W=6,mode=1,outIN=out,recIN=rec){
dev.new(height=H,width=W)
captionIN  <- "Comparison of (-1,1) standard dev. of covariates on Ricker RS for each species"
titleIN    <- paste(names(mod[[1]])[mode]," recruitment estimates ")
outIN   <-  outIN[outIN$mode==names(mod[[1]])[mode],]
recIN   <-  recIN[recIN$mode==names(mod[[1]])[mode],]
out_tmp <-  as_tibble(outIN)
out_tmp <-  out_tmp%>%filter(mode==levels(out_tmp$mode)[mode])
rec_tmp <-  as_tibble(recIN)
rec_tmp <-  data.frame(rec_tmp%>%filter(mode==levels(rec_tmp$mode)[mode]))
types<-levels(out_tmp$type)
upp <- out_tmp%>%filter(type==types[2],X1=='95%')
dwn <- out_tmp%>%filter(type==types[2],X1=='5%')
mid <- out_tmp%>%filter(type==types[2],X1=='50%')
mid2 <- out_tmp%>%filter(type==types[1],X1=='50%')
upp2 <- out_tmp%>%filter(type==types[1],X1=='95%')
dwn2 <- out_tmp%>%filter(type==types[1],X1=='5%')
out_tmp <- data.frame(out_tmp)
p <- ggplot(data=rec_tmp,aes(x=SSB,y=Rec))
p <- p + facet_wrap(sp~mod,scales="free",nrow=3)+ expand_limits(y = 0)
p <- p + geom_point(aes(x=SSB,y=Rec),col=coll_use[1])
# p <- p + geom_line(data=mid,aes(x=value.1,y=value),col=coll_use[5],inherit.aes = FALSE)
# p <- p + geom_ribbon(data=upp,aes(x=dwn$'value.1',ymin=dwn$value,ymax=upp$value),fill=coll_use[5],alpha=.2,inherit.aes = FALSE)
# p <- p + geom_line(data=mid2,aes(x=value.1,y=value),col=coll_use[3],inherit.aes = FALSE)
# p <- p + geom_ribbon(data=upp2,aes(x=dwn2$'value.1',ymin=dwn2$value,ymax=upp2$value),fill=coll_use[3],alpha=.2,inherit.aes = FALSE)
#
p <- p + geom_line(data=mid,aes(x=SSB,y=value),col=coll_use[5],inherit.aes = FALSE)
p <- p + geom_ribbon(data=upp,aes(x=SSB,ymin=dwn$value,ymax=upp$value),fill=coll_use[5],alpha=.2,inherit.aes = FALSE)
p <- p + geom_line(data=mid2,aes(x=SSB,y=value),col=coll_use[3],inherit.aes = FALSE)
p <- p + geom_ribbon(data=upp2,aes(x=SSB,ymin=dwn2$value,ymax=upp2$value),fill=coll_use[3],alpha=.2,inherit.aes = FALSE)
p <-  p + theme_light() +
labs(x=NULL, y=NULL,title=titleIN,
subtitle=NULL,
caption=captionIN) +
theme(plot.subtitle=element_text(margin=margin(b=20))) +
theme(legend.title=element_blank()) +
theme(legend.position="right") +
theme(legend.key.width = unit(.5, "cm")) +
theme(legend.text=element_text(size=5)) +
theme(legend.key.size=unit(.01, "cm")) +
theme(plot.margin=margin(t = 10, r = 10, b = 10, l =10))
p<- p+ theme_kir_EBM(sub_title_size=12,
sub_title_just="l",
axis_title_just = "cm") +
theme(legend.title=element_blank(),
legend.background = element_rect(colour = NA),
legend.key = element_rect(colour = "white", fill = NA))
p
}
plotCompareMod()
data(BS2017MS)
library(Rceattle)
data(BS2017SS)
data(BS2017MS)
devtools::install_github("grantdadams/Rceattle")
library(Rceattle)
data(BS2017SS)
data(BS2017MS)
R_hat<-function(N,gamma=-1,b=1,loga=1,beta=.2,lambda=.2,x){
sapply(N,function(NIn=N,gammaIN=gamma,bIn=b,logaIn=loga,betaIn=beta,lambdaIn=lambda){
gN <- NIn*exp(sum(lambdaIn*x))
hx <- exp(sum(betaIn*x))
return( exp(loga)*gN* ((1-bIn*gammaIN*gN)^(1/gammaIN))*hx)
}
)}
bseq<-seq(0,1,.01)
plot(bseq,R_hat(N=100,gamma=-1,b=bseq,a=1,beta=.2,lambda=.2,x=bseq),type="l")
gseq<-seq(-1,1,.01)
Nseq <- seq(0,200,1)
xseq <-Nseq*0
BETA <- 0
LAMBDA <-0
# ricker
plot(Nseq,R_hat(N=Nseq,gamma=.3,b=.01,loga=1,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
# Bev holt
lines(Nseq,R_hat(N=Nseq,gamma=-1,b=.1,loga=2,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
#linear
lines(Nseq,R_hat(N=Nseq,gamma=0,b=.1,loga=-1.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l")
#exponential:
lines(Nseq,R_hat(N=Nseq,gamma=1,b=-0.002,loga=-1.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l",col="red")
lines(Nseq,R_hat(N=Nseq,gamma=0,b=0,loga=-2.3,beta=BETA,lambda=LAMBDA,x=xseq),type="l",col="blue")
x_seq2<-datlist[[6]][[1]]$S_obs*0
plot(datlist[[6]][[1]]$S_obs,R_hat(N=datlist[[6]][[1]]$S_obs,gamma=a,b=-12.3076257,loga=1.2,beta=0,lambda=0,x=x_seq2),type="p")
g<- 0.126577
a<-3.320117
b<-4.517166e-06
S_obs<-rec$S_obs
Acovars<-Bcovars<-0
plot(S_obs,R_hat(N=S_obs,gamma=g,b=b,loga=log(a)/10,beta=0,lambda=0,x=x_seq2),type="p")
R_hat<-S_obs*0
for(i in 1:length(S_obs))
R_hat[i]  =  a*S_obs[i]*exp(Acovars)*( 1 - (b*g*S_obs[i]*exp(Acovars))^(1/g)  )*exp(Bcovars)
plot(S_obs,R_hat)
LAMBDA <-0
nobs  <- length(Nseq)
err   <- rnorm(nobs,0,.2)
AC    <- 1.2
xseq <-exp(err+c(0,err[-nobs])*AC)
xseq <- rep(2,nobs)
xseq2 <- rep(-2,nobs)
plot(xseq,type="l")
est       <-  read.csv("data/ignore/raw/ceattle_est_aclim_00_JunV3_2019_2.std",sep = "")
ln_mn_rec <-  est%>%filter(name=="ln_mn_rec")
rec_dev   <-  est%>%filter(name=="rec_dev")
nyrs      <-  (dim(rec_dev)/dim(ln_mn_rec))[1]
est       <-  read.csv("NotShared/ignore/raw/ceattle_est_aclim_00_JunV3_2019_2.std",sep = "")
ln_mn_rec <-  est%>%filter(name=="ln_mn_rec")
rec_dev   <-  est%>%filter(name=="rec_dev")
nyrs      <-  (dim(rec_dev)/dim(ln_mn_rec))[1]
est\
est
# 1.0. define directories
mod_fldr  <-  path.expand("~/Documents/D_AFSC_Files/Manuscripts/00_ROMS_CEATTLE_RS/data/runs/aclim_00_JunV2_2019_2")
rec_fldr  <-  file.path(mod_fldr,"Recruitment_files")
main
rec_fldr
run_est    <- FALSE
REcompile  <- TRUE
bias_corr  <- TRUE # bias correct sigma sensu Ludwig and Walters 1981 and Porch and Lauretta 2016
recruitAge <- 1    # what age is recruitment estimated in the model?
fityrsIN   <- 1980:2017
Eat_covIN  <- c(18, 20, 26, 28)
Eat_covIN  <- -99
load("NotShare/ignore/env_covars.Rdata")  # Bottom Temp object
load("NotShared/ignore/env_covars.Rdata")  # Bottom Temp object
load("data/in/env_covars.Rdata")  # Bottom Temp object
load("data/in/NPZcov.Rdata")      # key scaled indices from ROMSNPZ (by year, not yet lagged)
load("data/in/recruitment.Rdata")
load( "data/in/ms_run.Rdata" )
load( "NotShared/ms_run.Rdata" )
rec_yrs  <- yrs
# 1.4 load functions
source("R/futRfun.R")
GET_ESTM2 <- function(mode, s = 1){
plotdat     <-  smry_RS[[s]]
Rectxt      <-  Rec_2$TopR2.txt[[s]]
Rectxt_aic  <-  Rec_2$TopAIC.txt[[s]]
rec_path    <-  rec_fldr
estnm       <-  file.path(mod_fldr,"results/ceattle_est.std")
rsdat       <-  rs_data
covv        <-  covuse.all
return(list(covv = covv,  Rectxt = Rectxt, Rectxt_aic = Rectxt_aic,rsdat=rsdat,estnm=estnm,rec_path=rec_path,plotdat=plotdat))
}
# 1.5 set up mode for future R
mode = 1  # 1 = estimate simga, similar to ceattle approach
#years        <-  ms_run$data_list$styr-1+(1:(ms_run$data_list$nyrs))[-1]
ALLcovars    <-  ROMS_NPZ_covars[["aclim_hindcast.use"]]
rownames(ALLcovars)  <- ALLcovars$year
covars       <-  ALLcovars[which(ALLcovars$year%in%fityrsIN)-recruitAge,]
topmod       <-  which(names(covars)%in%c("BottomTemp","ColdPool","fallZavg","springZavg"))
topmod       <-  which(names(covars)%in%c("Btm_sal_tmp", "ColdPool" , "fallZavg" , "springZavg" ))
modc         <-  which((AICtable[[1]]$model)=="Btm_sal_tmp_ColdPool_fallZavg_springZavg_")
ROMS_NPZ_covars
NPZcov
head(NPZcov)
datlist3
rec_path
datlist2
datlist$rs_dat$rs_cov
names(datlist)
rm(list=ls()); setwd("D:/GitHub_cloud/futR")
#___________________________________________
# 1. Set things up
#___________________________________________
# rm(list=ls()) ; dir()
# load data, packages, setup, etc.
source("R/01_make.R")
#___________________________________________
# 2. Compile futR	(first time through - can skip this step after )
#___________________________________________
recompile_model <- FALSE # to recompile the model set to TRUE
if(recompile_model){
wd0 <- getwd()
setwd("src")
recompile('futR')
setwd(wd0)
}
# this will generate warnings - they can be ignored if "0" is returned
# read in the data and create a datlist
datlist <- makefutR_data("data/in/futR_Inputs.xlsx" )
# recruitment data:
datlist$rs_dat$R_obs
datlist$rs_dat$S_obs
# covar data:
datlist$rs_dat$rs_cov
# rec        <-  rec_dat[[1]]
# env        <-  env_covars
# which parameters to estimate with futR?
datlist$estparams
# starting values?
datlist$parameters
# parameter map:
datlist$maplist
# which phases to estimate in (not yet coded up)
datlist$phases
# set some global values for the demo below:
estparams <-  datlist$estparams[1:6]
rec       <-  data.frame(readxl::read_xlsx("data/in/futR_Inputs.xlsx" , sheet = "rec_data" ))
datlist$rs_dat$rs_cov
datlist2  <-  makeDat(
rectype    =  4,
tauIN      =  0,
sigMethod  =  1, # (default, no random effects)
estparams  =  estparams,
estMode    =  1,
rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
covars     =  NULL,
covars_sd  =  NULL)
datlist2$estparams["beta"] <- datlist$estparams["lambda"] <- TRUE
Rec4 <-  mm <-runmod(dlistIN   = datlist2,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# summarize results
dfR4    <-  data.frame(model = "Rec 4",
estimate  = as.vector(mm$sim),
parameter = names( mm$mle)[row(mm$sim)])
r4_fit  <- getFit(mm, nm = "recType = 4")
rm(mm)
# read in the data and create a datlist (rather than hand code it)
datlist <- makefutR_data("data/in/futR_Inputs.xlsx" )
datlist$rs_dat$rs_cov
datlist$rs_dat$sdrs_cov
estparams3 <-estparams
# Estimate covariate effects:
estparams3["beta"] <- estparams3["lambda"] <- TRUE
datlist3  <-  makeDat(
rectype    =  4,
tauIN      =  0,
sigMethod  =  1, # (default, no random effects)
estparams  =  estparams3,
estMode    =  1,
rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
beta_0     =  datlist$rs_dat$beta_0,
lambda_0   =  datlist$rs_dat$lambda_0,
covars     =  datlist$rs_dat$rs_cov,
covars_sd  =  datlist$rs_dat$sdrs_cov)
estparams3
datlist$rs_dat$rs_cov
# set the rectype to 4
datlist3$rs_dat$rectype <- 4
# run the basic model
Rec4_covar <-  mm <-runmod(dlistIN   = datlist,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# set the rectype to 4
datlist3$rs_dat$rectype <- 4
# run the basic model
Rec4_covar <-  mm <-runmod(dlistIN   = datlist,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
datlist
datlist$rs_dat$sdrs_cov
estparams3
datlist4  <-  makeDat(
rectype    =  4,
tauIN      =  0,
sigMethod  =  1, # (default, no random effects)
estparams  =  estparams3,
estMode    =  1,
rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
beta_0     =  datlist$rs_dat$beta_0,
lambda_0   =  datlist$rs_dat$lambda_0,
covars     =  datlist$rs_dat$rs_cov[2,],
covars_sd  =  datlist$rs_dat$sdrs_cov[2,])
datlist$rs_dat$rs_cov[2,]
matrix(datlist$rs_dat$rs_cov[2,],1,dim(datlist$rs_dat$rs_cov)[2])
matrix(datlist$rs_dat$rs_cov[2,],1,dim(datlist$rs_dat$rs_cov)[2])
datlist4  <-  makeDat(
rectype    =  4,
tauIN      =  0,
sigMethod  =  1, # (default, no random effects)
estparams  =  estparams3,
estMode    =  1,
rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
beta_0     =  datlist$rs_dat$beta_0,
lambda_0   =  datlist$rs_dat$lambda_0,
covars     =  matrix(datlist$rs_dat$rs_cov[2,],1,dim(datlist$rs_dat$rs_cov)[2]),
covars_sd  =  matrix(datlist$rs_dat$rs_cov[2,],1,dim(datlist$rs_dat$sdrs_cov)[2]))
# set the rectype to 4
datlist4$rs_dat$rectype <- 4
# run the basic model
Rec4_covar <-  mm <-runmod(dlistIN   = datlist,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# run the basic model
Rec5_covar <-  mm <-runmod(dlistIN   = datlist,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# summarize results
dfR5_c    <-  data.frame(model = "Rec 5 cov2",
estimate  = as.vector(mm$sim),
parameter = names( mm$mle)[row(mm$sim)])
rm(mm)
# read in the data and create a datlist
datlist <- makefutR_data("data/in/futR_Inputs.xlsx" )
# recruitment data:
datlist$rs_dat$R_obs
datlist$rs_dat$S_obs
# covar data:
datlist$rs_dat$rs_cov
# rec        <-  rec_dat[[1]]
# env        <-  env_covars
# which parameters to estimate with futR?
datlist$estparams
# starting values?
datlist$parameters
# parameter map:
datlist$maplist
# which phases to estimate in (not yet coded up)
datlist$phases
# set some global values for the demo below:
estparams <-  datlist$estparams[1:6]
rec       <-  data.frame(readxl::read_xlsx("data/in/futR_Inputs.xlsx" , sheet = "rec_data" ))
datlist2  <-  makeDat(
rectype    =  4,
tauIN      =  0,
sigMethod  =  1, # (default, no random effects)
estparams  =  estparams,
estMode    =  1,
rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
covars     =  NULL,
covars_sd  =  NULL)
datlist2$estparams["beta"] <- datlist$estparams["lambda"] <- TRUE
Rec4 <-  mm <-runmod(dlistIN   = datlist2,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# summarize results
dfR4    <-  data.frame(model = "Rec 4",
estimate  = as.vector(mm$sim),
parameter = names( mm$mle)[row(mm$sim)])
r4_fit  <- getFit(mm, nm = "recType = 4")
rm(mm)
#-----------------------------------------------
# Estimate covariate effects:
#-----------------------------------------------
# read in the data and create a datlist (rather than hand code it)
datlist <- makefutR_data("data/in/futR_Inputs.xlsx" )
datlist$rs_dat$rs_cov
datlist$rs_dat$sdrs_cov
estparams3 <- estparams
estparams3["beta"] <- estparams3["lambda"] <- TRUE
datlist3  <-  makeDat(
rectype    =  4,
tauIN      =  0,
sigMethod  =  1, # (default, no random effects)
estparams  =  estparams3,
estMode    =  1,
rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
beta_0     =  datlist$rs_dat$beta_0,
lambda_0   =  datlist$rs_dat$lambda_0,
covars     =  datlist$rs_dat$rs_cov,
covars_sd  =  datlist$rs_dat$sdrs_cov)
# set the rectype to 4
datlist3$rs_dat$rectype <- 4
# run the basic model
Rec4_covar <-  mm <-runmod(dlistIN   = datlist,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# summarize results
dfR4_c    <-  data.frame(model = "Rec 4 cov2",
estimate  = as.vector(mm$sim),
parameter = names( mm$mle)[row(mm$sim)])
df      <- rbind(dfR4,dfR4_c)
r4_fitc  <- getFit(mm, nm = "recType = 4 cov2")
rec_fit <- rbind(r4_fit,r4_fitc)
rm(mm)
#plot_par_pdf(df)
plot_rs(rec_fit)
#-----------------------------------------------
# compare to just Coldpool (second row)
#-----------------------------------------------
# Estimate covariate effects:
estparams3["beta"] <- estparams3["lambda"] <- TRUE
datlist4  <-  makeDat(
rectype    =  4,
tauIN      =  0,
sigMethod  =  1, # (default, no random effects)
estparams  =  estparams3,
estMode    =  1,
rec_years  =  rec$rec_year,
Rec        =  rec$Robs,
SSB        =  rec$SSB,
sdSSB      =  rec$sdSSB,
sdRec      =  rec$sdRobs,
beta_0     =  datlist$rs_dat$beta_0,
lambda_0   =  datlist$rs_dat$lambda_0,
covars     =  matrix(datlist$rs_dat$rs_cov[2,],1,dim(datlist$rs_dat$rs_cov)[2]),
covars_sd  =  matrix(datlist$rs_dat$rs_cov[2,],1,dim(datlist$rs_dat$sdrs_cov)[2]))
# set the rectype to 4
datlist4$rs_dat$rectype <- 4
# run the basic model
Rec5_covar <-  mm <-runmod(dlistIN   = datlist,
version   = 'futR',
recompile = FALSE,
simulate  = TRUE,
sim_nitr  = 1000)
# summarize results
dfR5_c    <-  data.frame(model = "Rec 5 cov2",
estimate  = as.vector(mm$sim),
parameter = names( mm$mle)[row(mm$sim)])
df      <- rbind(df,dfR5_c)
r5_fitc  <- getFit(mm, nm = "recType = 5 cov2")
rec_fit <- rbind(rec_fit,r5_fitc)
plot_rs(rec_fit)
plot_rs(rec_fit)
rec_fit
tail(rec_fit)
dev.off()
dev.off()
rec_fit
#plot_par_pdf(df)
plot_rs(rec_fit)
plot_par_pdf(df)
df
head(plot_par_pdf(df))
head(df)
r5_fitc
rmd2md(rmd_fl = "vingettes/futR_demo",md_fl = "README")
source("D:/GitHub_cloud/futR/R/sub_fun/rmd2md.R")
rmd2md(rmd_fl = "vingettes/futR_demo",md_fl = "README")
rmd2md(rmd_fl = "vingettes/futR_demo",md_fl = "README")
src_fldr
runRecMod
# load data, packages, setup, etc.
source("R/01_make.R")
#___________________________________________
# 2. Compile futR	(first time through - can skip this step after )
#___________________________________________
recompile_model <- FALSE # to recompile the model set to TRUE
source("D:/GitHub_cloud/futR/R/sub_fun/plot_rs.R")
rmd2md(rmd_fl = "vingettes/futR_demo",md_fl = "README")
rmd2md(rmd_fl = "vingettes/futR_demo",md_fl = "README")
